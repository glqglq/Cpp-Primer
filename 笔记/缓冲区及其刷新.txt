缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。
我们为什么要引入缓冲区呢？比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。
又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。
缓冲区 分为三种类型：全缓冲、行缓冲和不带缓冲。
1、全缓冲
在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。
2、行缓冲
在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是键盘输入数据。
3、不带缓冲
也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。

下列情况会引发缓冲区的刷新:
1、缓冲区满时；
2、执行flush语句；
3、执行endl语句；
4、关闭文件；
5、执行getchar语句：它的作用是单个的读取缓冲区里的数据； 用户输入的数据先存放在缓冲区里，然后当执行getchar(）时读取缓冲区里的相对第一个字符。如果出错返回 －1。
6、执行%*nc语句：n的值是可以根据需要而改变，表示的是吸收的字符的个数。用法和cin.getchar()相像，只不过它可以很方便的改变吸收的字符的个数。
7、执行ignore()语句： cin.ignore(n,ch); 其中 n 指的是忽略字符的个数，ch 代表的是终止的字符。 默认的情况下以 EOF结束
8、执行cin.sync()语句。 
如：
cout<<flush; //将显存的内容立即输出到显示器上进行显示
fflush(stdin);//std是标准的意思，in指的是输入，刷新成功返回0，失败返回EOF
scanf("%*5c%c",&ch);
cout<<endl;
相当于
cout<<”\n” <<flush;
